import math
import os
import time
from functools import partial

import numpy as np
import pygame

import byte_functions
from byte_functions import BYTES

xs = None
ys = None
last_byte_output = None
last_working_func = None
byte_beat_func_file = open(os.path.join(os.path.dirname(__file__), "byte_beat.func"), "r")


def setup(screen, etc):
    global xs, ys, color_palette, last_working_func, last_byte_output
    # Create grid
    x_range = np.arange(BYTES)
    y_range = np.arange(BYTES)
    grid = np.array(np.meshgrid(x_range, y_range)).T.reshape(-1, 2)
    xs = grid[:, 0]
    ys = grid[:, 1]
    last_working_func = None
    last_byte_output = np.random.rand(xs.shape[0])

    # Remove annoying errors (generated by byte beat function)
    np.seterr(divide='ignore', invalid='ignore')


def draw(screen, etc):
    start_draw = time.time()
    image = generate_image(etc)

    start = time.time()
    image_surface = pygame.surfarray.make_surface(image)
    pygame.transform.scale(image_surface, screen.get_rect().size, screen)  # smoothscale is too slow
    # log_time('surface', start)

    # log_time('draw', start_draw)


def generate_image(etc):
    start = time.time()
    # 'k1 * (1 - ain) + k2 * sin(sqrt(x**2, y**2)) + k3 * sin((x - 0.5) * (y - 0.5) * mod(t / 50, 50))'
    pixels = eval_byte_beat_function(etc)
    # log_time('byte_beat_function', start)

    start = time.time()
    pixels = np.fmod(np.abs(pixels), BYTES) / float(BYTES)
    # log_time('clean', start)

    start = time.time()
    from_color = etc.knob4
    to_color = etc.knob5
    pixels = grayscale_to_rgb(pixels, from_color, to_color)
    # log_time('grayscale_to_rgb', start)

    start = time.time()
    pixels = pixels.reshape((BYTES, BYTES, 3))
    # log_time('reshape', start)

    return pixels


def eval_byte_beat_function(etc):
    global last_byte_output, last_working_func
    # Load function from file
    byte_beat_func_file.seek(0)
    byte_byte_func_lines = byte_beat_func_file.readlines()
    byte_byte_func_lines = [
        line.replace('\r', '').replace('\n', '')
        for line in byte_byte_func_lines
        if not line.startswith('#')
    ]
    byte_byte_func = ' '.join(byte_byte_func_lines)

    # Prepare variables
    variables = {
        'x': xs,
        'y': ys,
        't': int(time.time() * 1000),  # TODO
        # 'mod': np.mod,
        # 'sin': lambda v: 0.5 + np.sin(v) / 2.0,
        'sin': byte_functions.sin,
        # 'cos': lambda v: 0.5 + np.cos(v) / 2.0,
        # 'sqrt': np.sqrt,
        'sqrt': byte_functions.sqrt,
        # 'ain': np.resize(np.array(etc.audio_in).astype('float32') / 32767 / 2, xs.shape),
        'trig': etc.audio_trig,
        'k1': etc.knob1,
        'k2': etc.knob2,
        'k3': etc.knob3,
        'k4': etc.knob4,
        'k5': etc.knob5,
        # 'rand': partial(np.random.rand, xs.shape[0]),
        'pi': math.pi,
        'o': last_byte_output,
    }

    try:
        last_byte_output = eval(byte_byte_func, variables)
        last_working_func = byte_byte_func
    except Exception as exc:
        print('Bad function: ', exc)
        if last_working_func:
            last_byte_output = eval(last_working_func, variables)
        else:
            return np.zeros(xs.shape)

    return last_byte_output


def grayscale_to_rgb(grayscale, from_color, to_color):
    """
    :param grayscale: [0, 1]
    :return:
    """
    color_palette = generate_color_palette(from_color, to_color)
    grayscale = (grayscale * 255).astype('uint8')
    colored = np.zeros((grayscale.shape[0], 3), dtype=np.uint8)
    colored = np.take(color_palette, grayscale, axis=0, out=colored)
    return colored


def generate_color_palette(from_color, to_color):
    """

    :param from_color: [0, 1]
    :param to_color: [0, 1]
    :return:
    """
    if from_color == to_color:
        from_color = 0.0
        to_color = 1.0

    step = (to_color - from_color) / 255.0
    scale = np.arange(from_color, to_color, step)
    red = 255 * (1 - (np.cos(scale * 3 * math.pi) * .5 + .5)) * scale
    green = 255 * (1 - (np.cos(scale * 7 * math.pi) * .5 + .5)) * scale
    blue = 255 * (1 - (np.cos(scale * 11 * math.pi) * .5 + .5)) * scale
    stacked = np.stack((red, green, blue), axis=-1).astype('uint8')
    return stacked


def log_time(name, start):
    if int(time.time()) % 10 == 1:
        print('%s %s ms' % (name, int((time.time() - start) * 1000)))